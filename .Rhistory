# how are you justifying nsim?
nsim = 900
n = c(10, 50, 500)
beta_true = c(0, 0.5, 2)
epsilon_dist = c("normal", "lognormal")
params = expand.grid(n = n,
n_sim = nsim,
beta_true = beta_true,
epsilon_dist = epsilon_dist)
# x0: Initial guess for the solution
# alpha: Step size value
# tol: Tolerance for stopping criterion
# max_iter: Maximum number of iterations
steepest_descent = function(x0, alpha, tol = 1e-6, max_iter = 100) {
x = x0
x_history = gradient_vec = rep(NA, length.out = max_iter)
for (iter in 1:max_iter) {
# store results
x_history[iter] = x
# Compute the gradient
gradient = 2 * x-100 + exp(x)/50
gradient_vec[iter] = gradient
# Check stopping criterion
if(sqrt(sum(gradient^2)) < tol){
message("Converged in", iter, "iterations.\n")
break
}
# Update the solution
x = x - alpha * gradient
}
return(list(solution = x,
x_history = x_history,
gradient = gradient_vec,
converged = (iter < max_iter),
niter = iter))
}
library(tidyverse)
knitr::opts_chunk$set(
echo = FALSE,
warning = FALSE,
message = FALSE,
fig.width = 7,
fig.height = 5
)
theme_set(theme_bw() + theme(legend.position = "bottom"))
test1 = steepest_descent(x0 = 1, alpha = 0.01)
plot(test1$x_history)
plot(test1$gradient)
test1 = steepest_descent(x0 = 1, alpha = 0.001)
test1 = steepest_descent(x0 = 1, alpha = 0.001)
plot(test1$x_history)
plot(test1$gradient)
test1 = steepest_descent(x0 = 1, alpha = 0.005)
plot(test1$x_history)
plot(test1$gradient)
test1 = steepest_descent(x0 = 8, alpha = 0.001)
test1 = steepest_descent(x0 = 8, alpha = 0.005)
plot(test1$x_history)
plot(test1$gradient)
test1 = steepest_descent(x0 = 8.3, alpha = 0.001)
test1 = steepest_descent(x0 = 8.3, alpha = 0.002)
plot(test1$x_history)
test1 = steepest_descent(x0 = 8.3, alpha = 0.005)
test1 = steepest_descent(x0 = 1, alpha = 0.005)
plot(test1$x_history)
plot(test1$gradient)
test1 = steepest_descent(x0 = 1, alpha = 0.01)
plot(test1$x_history)
plot(test1$gradient)
test1 = steepest_descent(x0 = 5, alpha = 0.001)
test1 = steepest_descent(x0 = 4, alpha = 0.001)
test1 = steepest_descent(x0 = 4, alpha = 0.005)
plot(test1$x_history)
plot(test1$gradient)
test1 = steepest_descent(x0 = 4, alpha = 0.1)
test1 = steepest_descent(x0 = 1, alpha = 0.1)
test1 = steepest_descent(x0 = 1, alpha = 0.01)
newton = function(x0, alpha, tol = 1e-6, max_iter = 100) {
x = x0
x_history = gradient_vec = rep(NA, length.out = max_iter)
for (iter in 1:max_iter) {
# store results
x_history[iter] = x
# Compute the gradient
derivtive1 = 2 * x-100 + exp(x)/50
derivtive2 = 2 + exp(x)/50
gradient = derivtive1/derivtive2
gradient_vec[iter] = gradient
# Check stopping criterion
if(sqrt(sum(derivtive1^2)) < tol){
message("Converged in", iter, "iterations.\n")
break
}
# Update the solution
x = x - gradient
}
return(list(solution = x,
x_history = x_history,
gradient = gradient_vec,
converged = (iter < max_iter),
niter = iter))
}
newton = function(x0, tol = 1e-6, max_iter = 100) {
x = x0
x_history = gradient_vec = rep(NA, length.out = max_iter)
for (iter in 1:max_iter) {
# store results
x_history[iter] = x
# Compute the gradient
derivtive1 = 2 * x-100 + exp(x)/50
derivtive2 = 2 + exp(x)/50
gradient = derivtive1/derivtive2
gradient_vec[iter] = gradient
# Check stopping criterion
if(sqrt(sum(derivtive1^2)) < tol){
message("Converged in", iter, "iterations.\n")
break
}
# Update the solution
x = x - gradient
}
return(list(solution = x,
x_history = x_history,
gradient = gradient_vec,
converged = (iter < max_iter),
niter = iter))
}
test1 = newton(x0 = 1)
plot(test1$x_history)
test1 = newton(x0 = -5)
plot(test1$x_history)
test1 = newton(x0 = 10)
plot(test1$x_history)
test1 = newton(x0 = 50)
plot(test1$x_history)
test1 = newton(x0 = 5)
plot(test1$x_history)
test1 = newton(x0 = 15)
plot(test1$x_history)
citation("bkmr")
library(tidyverse)
source(here::here("source", "01_simulate_data.R"))
source(here::here("source", "02_apply_method.R"))
source(here::here("source", "03_extract_estimates.R"))
nsim = (.95*(1-.95))/(.01^2)
# generate a random seed for each simulated dataset
seed = floor(runif(nsim, 1, 10000))
# generate a random seed for each simulated dataset
set.seed(111)
seed = floor(runif(nsim, 1, 10000))
results = as.list(rep(NA, nsim))
seed
set.seed(seed[i])
i=1
set.seed(seed[i])
#number of simulations
nsim = (.95*(1-.95))/(.01^2)
#number of sub iterations for t-interval
nboot_t = 200
n = c(10, 50, 500)
beta_true = c(0, 0.5, 2)
epsilon_dist = c("normal", "lognormal")
params = expand.grid(n = n,
n_sim = nsim,
beta_true = beta_true,
epsilon_dist = epsilon_dist)
# define simulation scenario
scenario = 1
params = params[scenario,]
####################
# simulate data
simdata = simulate_data(n = params$n,
true_beta = params$beta_true,
dist_epsilon = params$epsilon_dist)
x = rbinom(n, prob = p_trt)
x = rbinom(size = n, prob = p_trt)
source(here::here("source", "01_simulate_data.R"))
####################
# simulate data
simdata = simulate_data(n = params$n,
true_beta = params$beta_true,
dist_epsilon = params$epsilon_dist)
####################
# apply method(s)
fit = fit_model(simdata)
head(simdata)
source(here::here("source", "01_simulate_data.R"))
source(here::here("source", "02_apply_method.R"))
source(here::here("source", "03_extract_estimates.R"))
####################
# apply method(s)
fit = fit_model(simdata)
source(here::here("source", "01_simulate_data.R"))
source(here::here("source", "02_apply_method.R"))
source(here::here("source", "03_extract_estimates.R"))
####################
# simulate data
simdata = simulate_data(n = params$n,
true_beta = params$beta_true,
dist_epsilon = params$epsilon_dist)
####################
# apply method(s)
fit = fit_model(simdata)
####################
# calculate estimates
estimates = get_estimates(model_fit = fit,
true_beta = params$beta_true)
####################
# store results, including estimates, speed, parameter scenarios
estimates = estimates %>%
mutate(true_beta = params$beta_true,
n = params$n,
sigma2_true = params$sigma2_true)
####################
# calculate estimates
estimates = get_estimates(model_fit = fit,
true_beta = params$beta_true)
####################
# store results, including estimates, speed, parameter scenarios
estimates = estimates %>%
mutate(true_beta = params$beta_true,
n = params$n,
sigma2_true = params$epsilon_dist)
params
estimates
View(estimates)
sample(1:n, size = n, replace = TRUE)
sample(1, n, size = n, replace = TRUE)
sample(x = seq(1, n, 1), size = n, replace = TRUE)
sample(x = seq(1, params$n), size = params$n, replace = TRUE)
# non parametric bootstrap
simdata_star = simdata[sample(x = seq(1, params$n), size = params$n, replace = TRUE), ]
# non parametric bootstrap
simdata_boot = simdata[sample(x = seq(1, params$n), size = params$n, replace = TRUE), ]
# apply method(s)
fit = fit_model(simdata_boot)
# calculate estimates
estimates = get_estimates(model_fit = fit_boot,
true_beta = params$beta_true)
# apply method(s)
fit_boot = fit_model(simdata_boot)
# calculate estimates
estimates = get_estimates(model_fit = fit_boot,
true_beta = params$beta_true)
# calculate estimates
estimates_boot = get_estimates(model_fit = fit_boot,
true_beta = params$beta_true)
# store results
estimates_boot = estimates_boot %>%
mutate(true_beta = params$beta_true,
n = params$n,
sigma2_true = params$epsilon_dist)
####################
# store results
estimates_Wald = estimates %>%
mutate(true_beta = params$beta_true,
n = params$n,
sigma2_true = params$epsilon_dist)
simdata_boot_k = simdata_boot[sample(seq(1,n), size = n, replace = TRUE),]
simdata_boot_k = simdata_boot[sample(x = seq(1,n), size = n, replace = TRUE),]
simdata_boot_k = simdata_boot[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
simdata_boot_k = simdata_boot[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot = fit_model(simdata_boot_k)
simdata_boot_k = simdata_boot[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(simdata_boot_k)
# calculate estimates
estimates_boot_k = get_estimates(model_fit = fit_boot_k,
true_beta = params$beta_true)
boot_beta_k = rep(NA, nboot_t)
for(k in 1:nboot_t){
simdata_boot_k = simdata_boot[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(simdata_boot_k)
# calculate estimates
estimates_boot_k = get_estimates(model_fit = fit_boot_k,
true_beta = params$beta_true)
boot_beta_k
}
boot_beta_k = rep(NA, nboot_t)
for(k in 1:nboot_t){
simdata_boot_k = simdata_boot[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(simdata_boot_k)
# calculate estimates
estimates_boot_k = get_estimates(model_fit = fit_boot_k,
true_beta = params$beta_true)
boot_beta_k[k] = estimates_boot_k$beta_hat
}
# calculate tstar
se_star = sd(boot_beta_k)
# bootstrap data
boot_data = simdata[sample(x = seq(1, params$n), size = params$n, replace = TRUE), ]
# apply method(s)
fit_boot = fit_model(boot_data)
fit_boot$coefficients
coef(fit_boot)
coef(fit_boot)["x"]
# Nonparameteic bootstrap t-interval
boot_beta_k = rep(NA, nboot_t)
for(k in 1:nboot_t){
boot_data_k = boot_data[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(boot_data_k)
boot_beta_k[k] = coef(fit_boot_k)["x"]
}
# number of bootstrap
nboot = 500
# number of bootstrap for t interval
nboot_t = 200
beta_boot = tstar = rep(NA, nboot)
# bootstrap data
boot_data = simdata[sample(x = seq(1, params$n), size = params$n, replace = TRUE), ]
# apply method(s)
fit_boot = fit_model(boot_data)
# store results
beta_boot[b] = coef(fit_boot)["x"]
b=1
# store results
beta_boot[b] = coef(fit_boot)["x"]
# Nonparameteic bootstrap t-interval
boot_beta_k = rep(NA, nboot_t)
for(k in 1:nboot_t){
boot_data_k = boot_data[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(boot_data_k)
boot_beta_k[k] = coef(fit_boot_k)["x"]
}
# calculate tstar
se_star = sd(boot_beta_k)
# percentile interval
quantile(beta_boot, probs = c(alpha/2, 1-(alpha/2)))
## bootstrap t interval
t_quants = quantile(tstar, probs = c(alpha/2, 1-(alpha/2)))
# calculate tstar
se_star = sd(boot_beta_k)
tstar[b] = (beta_boot[b] - estimates$beta_hat)/se_star
b
tstar[b] = (beta_boot[b] - estimates$beta_hat)/se_star
tstar
beta_boot[b]
estimates$beta_hat
se_star
# calculate tstar
se_star = sd(boot_beta_k)
summary(boot_beta_k)
boot_data_k = boot_data[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(boot_data_k)
boot_beta_k[k] = coef(fit_boot_k)["x"]
boot_beta_k[k]
boot_beta_k
# Nonparameteic bootstrap t-interval
boot_beta_k = rep(NA, nboot_t)
for(k in 1:nboot_t){
boot_data_k = boot_data[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(boot_data_k)
boot_beta_k[k] = coef(fit_boot_k)["x"]
if(is.na(boot_beta_k[k])) {
break
}
}
boot_beta_k[k]
fit_boot_k
boot_data_k
# calculate tstar
se_star = sd(boot_beta_k, na.rm = T)
tstar[b] = (beta_boot[b] - estimates$beta_hat)/se_star
# number of bootstrap
nboot = 500
# number of bootstrap for t interval
nboot_t = 200
beta_boot = tstar = rep(NA, nboot)
for (b in 1:nboot) {
# bootstrap data
boot_data = simdata[sample(x = seq(1, params$n), size = params$n, replace = TRUE), ]
# apply method(s)
fit_boot = fit_model(boot_data)
# store results
beta_boot[b] = coef(fit_boot)["x"]
# Nonparameteic bootstrap t-interval
boot_beta_k = rep(NA, nboot_t)
for(k in 1:nboot_t){
boot_data_k = boot_data[sample(x = seq(1, params$n), size = params$n, replace = TRUE),]
# apply method(s)
fit_boot_k = fit_model(boot_data_k)
boot_beta_k[k] = coef(fit_boot_k)["x"]
}
# calculate tstar
se_star = sd(boot_beta_k, na.rm = T)
tstar[b] = (beta_boot[b] - estimates$beta_hat)/se_star
}
# percentile interval
quantile(beta_boot, probs = c(alpha/2, 1-(alpha/2)))
beta_boot
# percentile interval
quantile(beta_boot, probs = c(alpha/2, 1-(alpha/2)), na.rm = T)
alpha = 0.05
# percentile interval
quantile(beta_boot, probs = c(alpha/2, 1-(alpha/2)), na.rm = T)
tstar
## bootstrap t interval
t_quants = quantile(tstar, probs = c(alpha/2, 1-(alpha/2)), na.rm = T)
se_theta_hat = sd(beta_boot)
# lower CI
theta_hat - t_quants[2] *se_theta_hat
# lower CI
estimates$beta_hat - t_quants[2] * se_theta_hat
se_theta_hat = sd(beta_boot, na.rm = T)
# lower CI
estimates$beta_hat - t_quants[2] * se_theta_hat
# upper CI
estimates$beta_hat - t_quants[1] * se_theta_hat
